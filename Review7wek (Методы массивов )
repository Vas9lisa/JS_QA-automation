Массивы динамичекие - могут увеличиваться\уменьшаться по ходу кода 


создание массивов через литералы (квадратные скобки)
let arr = []
const arr1 = [1,2,3,]


объявление массива через вызов конструктора
let vas = new Array()
let vas = new Array(10) // 10 - колличество элементов в массиве. В этом случае - undefaind 10 штук
let vas = new Array(2, null ,false, 3, 4,)  // Здесь сразу сами элементы


length (количество эелементов \ длинна массива)
let vas = new Array(2, null ,false, 3, 4,)  // Здесь сразу сами элементы
vas.length = 3  // массив обризается до 3 элементов. утеря данных совсем
vas.length = 0  // cnfytn gecnjq массив



at (обращение к свойству)
vas.at(-1) == vas[vas.length - 1]   //Обращение к последнему элементу массива


push (Работа с КОНЦОМ массива) Добавление элементов в конце
vas.push(true)  // В массив добавится элемент true в конец массива


pop (Работа с КОНЦОМ массива) Удаление элементА в конце
vas.pop()  // Удаление последнего элемента. ТОЛЬКО ОДИН элемент. В скобках ни чего не надо указывать. Можно, но будет бесполезна
console.log(vas.pop())   //Выведет УДАЛЯЕМЫЙ элемент


unshift (Работа с НАЧАЛОМ массива) Работает МЕДЛЕННЕЕ push. Ибо идет перенумирация остальных элементов
vas.unshift(1, 2, 3)  // Добавляет элементы вперед массива. 


shift (Работа с НАЧАЛОМ массива) Работает МЕДЛЕННЕЕ pop. Ибо идет перенумирация остальных элементов
vas.shift()  // Удаляет ОДИН элемент в самом начале массива. работает как pop, только с первым элементом


concat (Объединение массивов)
vas = [1, 2]
caa = ['va', 'ba',]
las = [2, 1]
New = las.concat(vas, caa) //Выведет [2, 1, 1, 2,'va', 'ba',]


reverse (Переворот массива)
arr = [1, 2, 3, NaN]
arr.reverse()
Теперь масиива arr = [NaN, 3, 2, 1]



split (рассечение по значению. separator/ Из строки в массив) ТОЛЬКО STRING
str = "Hello World !"
cas = str.split(' ')  // Выведет массив ["Hello", "World", "!"]
nss = str.split('l')  // Выведет массив ["He", "", "o Wor", "d !"]
nss = str.split('')  // Выведет массив ["H", "e", "l", "l", "o", "W"  и т.д.]  РАЗБИВКА ПО БУКВАМ


join (Из массива в строку)
rrr = ["11", "111",]
rrr.join()   // "11111"
rrr.join(" ")   // "11 111"



slice (Делает новый массив от какого до элемента до каккого-нибудь.  .slace(1,6) При этом 6 элемент НЕ убдет включен в массив.
kae = [1,2,3,4,5,6,7]
NewKae = kae.slice(2,5)  // Будет новый массив со значениеми [3, 4, 5,]  От 2го элемента до 5того НЕ ВКЛЮЧАЯ пятого
NewKae = kae.slice(2)   // Будет от второго элемента до конца массива [3,4,5,6,7]


splice () .splice(index, deleteCount, el1, el2, ... elN)
kae = [1,2,3,4,5,6,7]
kae.splice(1,3, "E", "L", NaN)    // [1, "E", "L", NaN, 5, 6, 7]
kae.splice(4, 0, NaN) // kae = [1,2,3,NaN,4,5,6,7]


indexOf (поиск элемента) .indexOf(что ищем, от какого индекса ищем) Бежим с начала массива
uyt = ["h","e","L","L","o"]
index = uyt.indexOf("L")  // выведет 2 (второй элемент имеет значение "L")
index = uyt.indexOf("L", 3) // выведет 3.    

Если хотим найти все "L" сразу:
let i = uyt.indexOf("L")
while (i != -1) {
  console.log(i)
  i = uyt.indexOf("L", i+1)
  }


lastIndexOf (Бежим с конца массива)
то же самое, что indexOf, только идет отсчет с конца



includes(Есть ли в массиве искомый элемент - true или false) .includes(что ищем)
uyt = ["h","e","L","L","o"]
uyt.includes("e") //выведет true



find ().find(function(item, index, array){...}) (выводит элемент, который удовлетворяет условие)
const dfg = [2,4,8,10,12]
dfg.find(el => el % 2 != 0)  // выведет undefined
const dfg = [2,4,8,10,11, 13]
dfg.find(el => el % 2 != 0)  // выведет только 11. Ибо возвращает только первое попавшее значение




findIndex (как find, но показывает ИНДЕКС)
const dfg = [2,4,8,10,12]
dfg.find(el => el % 2 != 0)  // выведет -1
const dfg = [2,4,8,10,11, 13]
dfg.find(el => el % 2 != 0)  // выведет ИНДЕКС 4



filter (как find, только выводит ВСЕ элементы, которые подходят под условия)
const dfg = [2,4,8,10,11, 13]
let cv = dfg.filter(x => x % 2 !=0)  // Выведет новый массив [11,13]
lk = [NaN, "dd", 9, 7, "er", true]
sd = lk.filter(x => typeof x == "number")  //Выведет [NaN, 9, 7]


every (если все элементы соответствуют условию - true)
uf = [1, -2, 8, 9]
uf.every(x => x > 0]  // false  -2 не больше 0



some (Если хоть оддин  из элементов соответствуют условию - true)
uf = [1, -2, 8, 9]
uf.every(x => x > 0]  //true ибо есть элементы, которые больше 0 
